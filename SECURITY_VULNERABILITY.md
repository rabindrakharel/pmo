# Security Vulnerability Assessment Report
## Huron Home Services - PMO Enterprise Platform

**Assessment Date:** 2025-10-13
**Project Version:** 1.0.0
**Assessment Type:** Comprehensive Security Analysis (Authentication, API, Database, Frontend)

---

## Executive Summary

This document outlines identified security vulnerabilities, threats, and recommendations for the PMO Enterprise Platform. The assessment covers authentication mechanisms, API endpoints, database interactions, RBAC implementation, and frontend security.

### Risk Classification
- 🔴 **CRITICAL** - Immediate action required
- 🟠 **HIGH** - High priority, should be addressed soon
- 🟡 **MEDIUM** - Moderate risk, plan remediation
- 🟢 **LOW** - Minor issue, address when convenient
- ℹ️ **INFO** - Best practice recommendation

---

## 1. Authentication & Authorization Vulnerabilities

### 🔴 CRITICAL: JWT Secret in Source Code
**File:** `/apps/api/src/server.ts:62`
**Issue:** Hardcoded JWT secret used in example/testing
```typescript
JWT_SECRET="your-super-secret-jwt-key-change-in-production"
```
**Impact:**
- Anyone with access to the source code can forge valid JWT tokens
- Complete authentication bypass possible
- Ability to impersonate any user including administrators

**Exploitation:**
```javascript
// Attacker can create valid tokens for any user
const jwt = require('jsonwebtoken');
const token = jwt.sign(
  { sub: 'any-user-id', email: 'admin@example.com' },
  'your-super-secret-jwt-key-change-in-production'
);
```

**Remediation:**
1. Generate a cryptographically strong secret (minimum 256 bits)
2. Store in environment variables only, never in source code
3. Use different secrets for dev/staging/production
4. Rotate secrets periodically (recommend every 90 days)
5. Implement secret management system (AWS Secrets Manager, HashiCorp Vault)

```bash
# Generate secure secret
openssl rand -base64 64
```

---

### 🟠 HIGH: No JWT Token Revocation/Blacklisting
**File:** `/apps/api/src/modules/auth/routes.ts:367-384`
**Issue:** Logout endpoint doesn't actually invalidate tokens
```typescript
fastify.post('/logout', async (request, reply) => {
  // Since we're using stateless JWT tokens, logout is mainly for client-side cleanup
  return { message: 'Logged out successfully' };
});
```

**Impact:**
- Stolen tokens remain valid until expiration (24 hours default)
- No way to force logout compromised accounts
- Employee termination doesn't immediately revoke access

**Remediation:**
1. Implement Redis-based token blacklist
2. Add token revocation on logout
3. Implement sliding session windows
4. Consider refresh token rotation strategy

```typescript
// Recommended implementation
const revokedTokens = new Set(); // Or use Redis
fastify.post('/logout', { preHandler: [fastify.authenticate] },
  async (request, reply) => {
    const token = request.headers.authorization?.split(' ')[1];
    await redis.setex(`revoked:${token}`, 86400, '1');
    return { message: 'Logged out successfully' };
});
```

---

### 🟠 HIGH: No Account Lockout on Failed Login Attempts
**File:** `/apps/api/src/modules/auth/routes.ts:78-137`
**Issue:** No rate limiting or account lockout mechanism

**Impact:**
- Brute force attacks possible
- Password spraying attacks feasible
- Credential stuffing attacks viable

**Remediation:**
1. Implement account lockout after N failed attempts (recommend 5-10)
2. Add progressive delays (exponential backoff)
3. Implement CAPTCHA after 3 failed attempts
4. Log and alert on suspicious login patterns
5. Consider implementing 2FA/MFA

```typescript
// Example implementation
const loginAttempts = new Map();
if (loginAttempts.get(email) > 5) {
  return reply.status(429).send({
    error: 'Account temporarily locked. Try again in 15 minutes'
  });
}
```

---

### 🟠 HIGH: Weak Password Policy
**File:** `/apps/api/src/modules/auth/routes.ts:20-23`
**Issue:** Minimal password requirements (only minLength: 1)
```typescript
password: Type.String({ minLength: 1 }),
```

**Impact:**
- Users can set weak passwords ('a', '1', 'password')
- Easy to crack via brute force or dictionary attacks

**Remediation:**
```typescript
password: Type.String({
  minLength: 12,
  pattern: '^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]',
}),
```

**Policy Requirements:**
- Minimum 12 characters
- Require: uppercase, lowercase, number, special character
- Check against common password lists (Have I Been Pwned API)
- Prevent password reuse (store 5 previous password hashes)
- Enforce password expiration (90-180 days)

---

### 🟡 MEDIUM: Password Hash in Login Error Messages
**File:** `/apps/api/src/modules/auth/routes.ts:103-106`
**Issue:** Password hash retrieved but could leak in error logs
```typescript
const passwordHash = employee.password_hash as string | null;
if (!passwordHash) {
  return reply.status(401).send({ error: 'Account not properly configured' });
}
```

**Impact:**
- If error logging includes employee object, password hash could be logged
- Hash could be exposed in debug mode or error tracking systems

**Remediation:**
- Never include password_hash in SELECT statements unless absolutely necessary
- Use separate query for authentication
- Sanitize all error logs

---

### 🟡 MEDIUM: No Session Timeout for Inactive Users
**File:** `/apps/api/src/lib/config.ts:17`
**Issue:** JWT expiration set to 24 hours with no inactivity check

**Impact:**
- Unattended workstations remain authenticated
- Increased window for session hijacking

**Remediation:**
1. Reduce token expiration to 2-4 hours
2. Implement refresh tokens (7-30 days)
3. Track last activity timestamp
4. Auto-logout after 15-30 minutes of inactivity

---

## 2. SQL Injection Vulnerabilities

### ✅ GOOD: Using Parameterized Queries
**Files:** All route files in `/apps/api/src/modules/*/routes.ts`
**Status:** The project correctly uses Drizzle ORM with parameterized queries via `sql` template literals, which provides protection against SQL injection.

```typescript
// SAFE - Parameters are properly escaped
const result = await db.execute(sql`
  SELECT * FROM app.d_employee WHERE email = ${email}
`);
```

### 🟢 LOW: Search Parameter Concatenation
**File:** `/apps/api/src/modules/employee/routes.ts:187-198`
**Issue:** Search terms use ILIKE with wildcards
```typescript
sql`COALESCE(name, '') ILIKE ${`%${search}%`}`
```

**Status:** Currently SAFE because Drizzle escapes the entire string, but could be vulnerable if implementation changes.

**Recommendation:**
- Add input validation/sanitization for search terms
- Limit search string length (max 100 characters)
- Strip special characters that could cause regex issues

```typescript
const sanitizedSearch = search
  .replace(/[%_\\]/g, '\\$&')  // Escape SQL wildcards
  .substring(0, 100);
```

---

## 3. RBAC & Authorization Vulnerabilities

### 🔴 CRITICAL: Missing Authentication on Multiple Endpoints
**Files:** Multiple route files
**Issue:** Some endpoints lack `preHandler: [fastify.authenticate]`

**Affected Endpoints:**
- `/api/v1/auth/scopes/:entityType` (line 238) - Missing auth
- `/api/v1/biz/:id/children` (line 168) - Missing auth
- `/api/v1/biz/:id/creatable` (line 130) - Missing auth
- POST `/api/v1/employee` (line 331) - Missing auth
- DELETE `/api/v1/employee/:id` (line 527) - Missing auth

**Impact:**
- Unauthenticated users can access sensitive data
- Unauthorized user creation possible
- Data manipulation without authentication

**Remediation:**
Add authentication to ALL endpoints except login:
```typescript
fastify.get('/api/v1/auth/scopes/:entityType', {
  preHandler: [fastify.authenticate],  // ADD THIS
  schema: { ... }
}, async (request, reply) => { ... });
```

---

### 🟠 HIGH: Inconsistent RBAC Enforcement
**File:** `/apps/api/src/modules/rbac/entity-permission-rbac-gate.ts`
**Issue:** Some endpoints check RBAC, others don't

**Examples:**
✅ Good (has RBAC): `/apps/api/src/modules/biz/routes.ts:254`
```typescript
const hasAccess = await hasPermissionOnEntityId(userId, 'biz', bizId, 'view');
if (!hasAccess) {
  return reply.status(403).send({ error: 'Access denied' });
}
```

❌ Bad (no RBAC): Some endpoints only check authentication, not authorization

**Remediation:**
1. Create Fastify decorator for consistent RBAC checking
2. Audit all endpoints for RBAC enforcement
3. Default-deny approach: require explicit permission grants

```typescript
fastify.decorate('authorizeEntity', async function(
  request: any,
  reply: any,
  entityType: string,
  action: EntityAction
) {
  const userId = request.user?.sub;
  const entityId = request.params.id || 'all';

  const hasAccess = await hasPermissionOnEntityId(
    userId, entityType, entityId, action
  );

  if (!hasAccess) {
    reply.status(403).send({ error: 'Insufficient permissions' });
  }
});
```

---

### 🟡 MEDIUM: Admin Role Detection is Simplistic
**File:** `/apps/api/src/modules/auth/routes.ts:226`
**Issue:** Admin detection based on permission count
```typescript
isAdmin: totalEntities > 20, // Simple admin check
```

**Impact:**
- Users with many permissions incorrectly identified as admin
- Real admins might not be detected
- No proper role hierarchy

**Remediation:**
1. Create proper `d_role` table with admin flag
2. Implement role-based permissions separate from entity permissions
3. Add `is_admin` or `role_id` to employee table

---

### 🟡 MEDIUM: No Audit Logging for Sensitive Operations
**Files:** All route files
**Issue:** No audit trail for authentication, authorization failures, or sensitive data access

**Impact:**
- No forensic capability after security incidents
- Can't detect insider threats
- Compliance issues (SOC 2, ISO 27001)

**Remediation:**
Implement comprehensive audit logging:
```typescript
await db.execute(sql`
  INSERT INTO app.audit_log (
    employee_id, action, entity_type, entity_id,
    ip_address, user_agent, success, timestamp
  ) VALUES (
    ${userId}, ${action}, ${entityType}, ${entityId},
    ${request.ip}, ${request.headers['user-agent']},
    ${success}, NOW()
  )
`);
```

**Log Events:**
- All authentication attempts (success/failure)
- Authorization failures
- CRUD operations on sensitive entities (employees, RBAC, financial data)
- Permission changes
- Admin actions
- Data exports

---

## 4. Sensitive Data Exposure

### 🔴 CRITICAL: PII in API Responses
**File:** `/apps/api/src/modules/employee/routes.ts:207-224`
**Issue:** Sensitive PII returned in list endpoint
```typescript
sin, birthdate, citizenship, security_clearance,
emergency_contact_name, emergency_contact_phone,
salary_band, pay_grade
```

**Impact:**
- Social Insurance Numbers exposed
- Birthdates (identity theft risk)
- Salary information leaked
- Emergency contacts exposed

**Remediation:**
1. Remove PII from list endpoints (only show in detail view with proper permissions)
2. Implement field-level permissions
3. Mask/redact sensitive fields based on user role
4. Use the existing `filterUniversalColumns` more aggressively

```typescript
const piiFields = ['sin', 'birthdate', 'salary_band', 'pay_grade'];
const filteredData = employees.map(emp => {
  const filtered = { ...emp };
  if (!userPermissions.canSeePII) {
    piiFields.forEach(field => delete filtered[field]);
  }
  return filtered;
});
```

---

### 🟠 HIGH: Password Hashes in Database Queries
**Issue:** Password hashes retrieved unnecessarily

**Remediation:**
- Never SELECT password_hash unless authenticating
- Create separate authentication service
- Use database views that exclude password_hash

---

### 🟠 HIGH: Demo Credentials in Frontend Code
**File:** `/apps/web/src/components/auth/LoginForm.tsx:129-133`
**Issue:** Demo credentials displayed in login form
```typescript
james.miller@huronhome.ca / password123
```

**Impact:**
- Production deployments might keep demo credentials
- Known test accounts become attack targets

**Remediation:**
1. Remove from production builds
2. Use environment variable flag to control display
3. Ensure demo accounts disabled in production

```typescript
{import.meta.env.MODE === 'development' && (
  <div className="text-xs text-gray-500 mt-1">
    Demo: james.miller@huronhome.ca / password123
  </div>
)}
```

---

### 🟡 MEDIUM: Verbose Error Messages
**File:** Multiple route files
**Issue:** Detailed error messages leak system information
```typescript
return reply.status(500).send({ error: 'Internal server error' });
fastify.log.error('Error fetching business unit:', error as any);
```

**Impact:**
- Error messages might expose database structure
- Stack traces could reveal file paths and dependencies
- Helps attackers map system architecture

**Remediation:**
1. Generic errors to users
2. Detailed errors only in logs
3. Different error handling for dev vs production

```typescript
if (config.NODE_ENV === 'production') {
  return reply.status(500).send({ error: 'Internal server error' });
} else {
  return reply.status(500).send({
    error: error.message,
    stack: error.stack  // Only in dev
  });
}
```

---

## 5. Frontend Security (XSS, CSRF)

### ✅ GOOD: React's Built-in XSS Protection
**Status:** React automatically escapes values in JSX, providing XSS protection

### 🟠 HIGH: JWT Token in localStorage
**File:** `/apps/web/src/contexts/AuthContext.tsx:38`
**Issue:** JWT stored in localStorage (vulnerable to XSS)
```typescript
localStorage.setItem('auth_token', token);
```

**Impact:**
- If XSS vulnerability exists, token can be stolen
- Malicious browser extensions can access localStorage
- Token persists even after browser close

**Remediation:**
1. Use httpOnly cookies instead of localStorage
2. Implement proper CSRF protection for cookies
3. Consider short-lived tokens with refresh mechanism

```typescript
// Backend sets httpOnly cookie
reply.setCookie('auth_token', token, {
  httpOnly: true,
  secure: true,
  sameSite: 'strict',
  maxAge: 3600
});
```

---

### 🟠 HIGH: No CSRF Protection
**File:** `/apps/api/src/server.ts`
**Issue:** No CSRF token validation for state-changing operations

**Impact:**
- Attackers can trick users into performing unwanted actions
- Particularly dangerous for admin accounts

**Remediation:**
1. Implement CSRF tokens for all POST/PUT/DELETE requests
2. Use `@fastify/csrf-protection` plugin
3. Validate CSRF token on backend

```typescript
await fastify.register(require('@fastify/csrf-protection'), {
  sessionPlugin: '@fastify/session',
  cookieOpts: { signed: true }
});
```

---

### 🟡 MEDIUM: CORS Configuration Too Permissive
**File:** `/apps/api/src/server.ts:34-52`
**Issue:** Allows all localhost origins
```typescript
if (origin.includes('localhost') || origin.includes('127.0.0.1')) {
  return cb(null, true);
}
```

**Impact:**
- Any application running on localhost can make requests
- Vulnerable to local malware

**Remediation:**
```typescript
const allowedOrigins = [
  'http://localhost:5173',  // Specific port only
  'http://localhost:3000',
  config.WEB_ORIGIN
];
if (allowedOrigins.includes(origin)) {
  return cb(null, true);
}
```

---

### 🟡 MEDIUM: No Content Security Policy
**File:** `/apps/api/src/server.ts:28-30`
**Issue:** CSP disabled
```typescript
contentSecurityPolicy: false, // Disable for development
```

**Remediation:**
Enable CSP in production:
```typescript
contentSecurityPolicy: config.NODE_ENV === 'production' ? {
  directives: {
    defaultSrc: ["'self'"],
    scriptSrc: ["'self'", "'unsafe-inline'"],  // Minimize unsafe-inline
    styleSrc: ["'self'", "'unsafe-inline'"],
    imgSrc: ["'self'", "data:", "https:"],
    connectSrc: ["'self'", config.API_ORIGIN],
    fontSrc: ["'self'"],
    objectSrc: ["'none'"],
    mediaSrc: ["'self'"],
    frameSrc: ["'none'"],
  }
} : false
```

---

## 6. Rate Limiting & DoS Protection

### 🟡 MEDIUM: Global Rate Limiting Only
**File:** `/apps/api/src/server.ts:54-58`
**Issue:** Single rate limit for all endpoints
```typescript
max: 100,
timeWindow: '1 minute',
```

**Impact:**
- Login endpoint needs stricter limits
- Public endpoints could benefit from higher limits
- No per-IP or per-user limits

**Remediation:**
Implement endpoint-specific rate limiting:
```typescript
// Strict limit for login
fastify.post('/login', {
  config: {
    rateLimit: {
      max: 5,
      timeWindow: '1 minute'
    }
  }
}, loginHandler);

// Moderate limit for API
fastify.get('/api/v1/*', {
  config: {
    rateLimit: {
      max: 1000,
      timeWindow: '1 minute'
    }
  }
});
```

---

## 7. Database Security

### ✅ GOOD: Prepared Statements
**Status:** Using Drizzle ORM with parameterized queries

### 🟠 HIGH: Database Credentials in Environment Variables
**File:** `.env` files
**Issue:** Database credentials stored in plain text

**Remediation:**
1. Use secret management service
2. Encrypt .env files in repositories
3. Use IAM authentication for cloud databases
4. Implement credential rotation

---

### 🟡 MEDIUM: No Connection Encryption Enforcement
**File:** `/apps/api/src/lib/config.ts:10`
**Issue:** DATABASE_URL doesn't enforce SSL

**Remediation:**
```typescript
DATABASE_URL: z.string().url().refine(
  url => url.includes('sslmode=require') || url.includes('ssl=true'),
  'Database connection must use SSL'
)
```

---

## 8. Infrastructure & Deployment

### 🔴 CRITICAL: Default Credentials in Documentation
**File:** `CLAUDE.md`
**Issue:** Default credentials documented and potentially used
```
Email: james.miller@huronhome.ca
Password: password123
```

**Remediation:**
1. Force password change on first login
2. Never use same credentials across environments
3. Implement strong password policy from day one

---

### 🟠 HIGH: No HTTPS Enforcement
**File:** `/apps/api/src/server.ts`
**Issue:** No redirect from HTTP to HTTPS

**Remediation:**
```typescript
if (config.NODE_ENV === 'production') {
  fastify.addHook('onRequest', async (request, reply) => {
    if (request.headers['x-forwarded-proto'] !== 'https') {
      return reply.redirect(301, `https://${request.hostname}${request.url}`);
    }
  });
}
```

---

### 🟡 MEDIUM: Swagger UI in Production
**File:** `/apps/api/src/server.ts:95-101`
**Issue:** API documentation exposed

**Remediation:**
```typescript
if (config.NODE_ENV !== 'production') {
  await fastify.register(swaggerUI, { ... });
}
```

---

## 9. Dependency Vulnerabilities

### 🟡 MEDIUM: Outdated Dependencies
**Recommendation:** Regularly run security audits

```bash
# Check for vulnerabilities
pnpm audit

# Update dependencies
pnpm update --latest

# Use automated tools
pnpm add -D @dependabot/automated-security
```

---

## 10. Pen Testing Attack Vectors

### Potential Attack Scenarios

#### 1. **Account Takeover via JWT Forgery**
- Attacker obtains hardcoded JWT secret
- Forges token with admin privileges
- Full system compromise

#### 2. **SQL Injection via Search Parameters**
- Currently mitigated by Drizzle ORM
- Risk if developers bypass ORM

#### 3. **Privilege Escalation via RBAC Bypass**
- Access endpoints without authentication
- Manipulate entity permissions

#### 4. **Session Hijacking**
- Steal JWT from localStorage via XSS
- Token remains valid for 24 hours

#### 5. **Brute Force Login**
- No account lockout
- No progressive delays
- Can try unlimited password combinations

#### 6. **Data Exfiltration**
- List all employees with PII
- No audit trail
- Access salary/SIN data

---

## Remediation Priority Matrix

### Critical (Immediate - 0-7 days)
1. ✅ Change JWT secret to cryptographically strong value
2. ✅ Add authentication to all endpoints
3. ✅ Remove PII from list endpoints
4. ✅ Disable demo accounts in production

### High Priority (7-30 days)
1. ✅ Implement JWT token revocation
2. ✅ Add account lockout mechanism
3. ✅ Implement CSRF protection
4. ✅ Move JWT from localStorage to httpOnly cookies
5. ✅ Enforce RBAC consistently across all endpoints

### Medium Priority (30-90 days)
1. ✅ Implement comprehensive audit logging
2. ✅ Add field-level permissions
3. ✅ Enforce strong password policy
4. ✅ Add endpoint-specific rate limiting
5. ✅ Enable CSP in production
6. ✅ Database connection encryption

### Low Priority (90+ days)
1. ✅ Implement 2FA/MFA
2. ✅ Add security headers analyzer
3. ✅ Penetration testing
4. ✅ Security training for developers
5. ✅ Bug bounty program

---

## Security Testing Recommendations

### 1. Automated Security Scanning
```bash
# SAST (Static Analysis)
npm install -D @eslint/plugin-security
eslint --ext .ts,.tsx .

# Dependency scanning
npm audit --audit-level=high

# Docker image scanning
docker scan pmo-api:latest
```

### 2. Dynamic Testing
- OWASP ZAP automated scan
- Burp Suite Professional
- SQLMap for SQL injection testing
- JWT.io for token validation

### 3. Manual Testing Checklist
- [ ] Test authentication bypass
- [ ] Test authorization bypass
- [ ] Test SQL injection on all inputs
- [ ] Test XSS on all user inputs
- [ ] Test CSRF on state-changing operations
- [ ] Test session management
- [ ] Test file upload (if applicable)
- [ ] Test API rate limiting
- [ ] Test error handling
- [ ] Test password reset flow

---

## Compliance Considerations

### GDPR (EU)
- ⚠️ PII exposure in APIs
- ⚠️ No data retention policies
- ⚠️ No consent management
- ⚠️ No data export mechanism
- ⚠️ No right-to-be-forgotten implementation

### SOC 2
- ⚠️ No audit logging
- ⚠️ No access reviews
- ⚠️ No incident response plan
- ⚠️ No security monitoring

### PIPEDA (Canada)
- ⚠️ SIN handling not compliant
- ⚠️ No safeguard documentation
- ⚠️ No breach notification process

---

## Secure Development Practices

### Code Review Checklist
- [ ] All endpoints have authentication
- [ ] RBAC enforced on sensitive operations
- [ ] Input validation on all user inputs
- [ ] Output encoding to prevent XSS
- [ ] No secrets in code
- [ ] Error messages are generic
- [ ] Audit logging for sensitive operations

### Security Training Topics
1. OWASP Top 10
2. Secure coding practices
3. JWT best practices
4. SQL injection prevention
5. XSS/CSRF prevention
6. Password storage and hashing
7. Secure API design

---

## Contact & Escalation

For security concerns:
1. Do NOT create public GitHub issues
2. Email: security@huronhome.ca
3. Use encrypted communication for sensitive issues
4. Expected response time: 24-48 hours

---

## Document Revision History

| Version | Date | Author | Changes |
|---------|------|--------|---------|
| 1.0 | 2025-10-13 | Security Assessment | Initial security audit |

---

## References

- [OWASP Top 10](https://owasp.org/www-project-top-ten/)
- [OWASP API Security Top 10](https://owasp.org/www-project-api-security/)
- [CWE Top 25](https://cwe.mitre.org/top25/)
- [NIST Cybersecurity Framework](https://www.nist.gov/cyberframework)
- [JWT Security Best Practices](https://tools.ietf.org/html/rfc8725)
